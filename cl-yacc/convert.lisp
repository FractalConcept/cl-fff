(eval-when (:compile-toplevel :load-toplevel)
(defun convert-parser-to-cl-yacc (productions)
  (flet ((make-arg-list (n)
	   (loop for i from 1 to n collect (intern (format nil "$~d" i)))))
    (loop with groupings = (list ())
       for ((symbol . expansion) . body) in productions 
       for arg-list = (make-arg-list (length expansion))
       for yacc-production = `((,@expansion #'(lambda ,arg-list
						(declare (ignorable ,@arg-list))
						,@body)))
       for previous-prod = (find symbol groupings :key #'first)
       do (if previous-prod
	      (setf (cdr (last previous-prod)) yacc-production)
	      (setf (cdr (last groupings)) (list (cons symbol yacc-production))))
       finally (return (rest groupings)))))

(defmacro yacc-parser ((name &rest args) &rest productions)
  `(yacc:define-parser ,name
       ,@args 
       ,@(convert-parser-to-cl-yacc productions))))

#+use-cl-yacc
(yacc-parser (*pdf-parser*
	      (:start-symbol pdf-data)
	      (:terminals (:xref :trailer :n :f :obj :endobj :integer :token :start-dict :end-dict :name
				 :string :true :false :start-array :end-array :r :endstream :stream)))
  ((pdf-data trailer) $1)
  ((pdf-data object) $1)
  ((trailer :xref xrefs :trailer dictionary) (setf *force-eof* t)(list $2 $4))
  ((xrefs xref xrefs) (cons $1 $2))
  ((xrefs xref) (list $1))
  ((xref integer integer xref-type) (list $1 $2 $3))
  ((xref-type ) :start-table)
  ((xref-type :n) :n)
  ((xref-type :f) :f)
  ((object number gen-number :obj content :endobj) (setf *force-eof* t)(list $1 $2 $4))
  ((number integer) $1)
  ((gen-number integer) $1)
  ((content val) $1)
  ((integer :integer) $1)
  ((token :token) $1)
  ((dictionary :start-dict key-val* :end-dict) (%make-dictionary $2))
  ((dictionary :start-dict :end-dict) (%make-dictionary nil))
  ((key-val* key-val key-val*) (cons $1 $2))
  ((key-val* key-val) (list $1))
  ((key-val key val) (cons $1 $2))
  ((key-val key object-ref) (cons $1 $2))
  ((key token) $1)
  ((val token) $1)
  ((val integer) $1)
  ((val :name) $1)
  ((val :string) $1)
  ((val :true) :true)
  ((val :false) :false)
  ((val stream) $1)
  ((val dictionary) $1)
  ((val array) $1)
  ((array :start-array values :end-array) (convert-to-array $2))
  ((array :start-array :end-array) (vector))
  ((values val values) (cons $1 $2))
  ((values :r values) (cons :r $2))
  ((values val) (list $1))
  ((values :r) (list :r))
  ((stream  start-stream :endstream) $1)
  ((start-stream :start-dict key-val* :end-dict :stream)(%make-stream $2))
  ((object-ref integer integer :R) (%make-obj-ref $1 $2)))
