(in-package interface)(defclass elastic () ((initial-value    :initform 1.0 :accessor initial-value   :initarg :value :type float)  (min-value        :initform 0.0 :accessor min-value       :initarg :min :type float)  (max-value        :initform 1000000.0 :accessor max-value :initarg :max :type float)  (elasticity       :initform 1.0 :accessor elasticity      :initarg :elasticity :type float)  (compressibility  :initform 1.0 :accessor compressibility :initarg :compressibility :type float)  (final-value      :initform 0.0 :accessor final-value     :type float)  (blocked          :initform ()  :accessor blocked         :type float)  ))(defun duplicate-elastic (el)  (make-instance 'elastic		 :value (initial-value el)		 :min (min-value el)		 :max (max-value el)		 :elasticity (elasticity el)		 :compressibility (compressibility el)))(defun get-elasticity (el)  (if (blocked el)      0.0      (elasticity el)))(defun get-compressibility (el)  (if (blocked el)      0.0      (compressibility el)));; expand returns t if it blocked THIS call () else(defun expand-elastic (el expansion)  (if (blocked el)      ()      (let ((new-value (+ (initial-value el) (* (elasticity el) expansion))))	(if (> new-value (max-value el))	    (setf (final-value el) (max-value el) (blocked el) t)	    (setf (final-value el) new-value (blocked el) ())))));; compress returns t if it blocked THIS call () else(defun compress-elastic (el expansion)  (if (blocked el)      ()      (let ((new-value (+ (initial-value el) (* (compressibility el) expansion))))	(if (< new-value (min-value el))	    (setf (final-value el) (min-value el) (blocked el) t)	    (setf (final-value el) new-value (blocked el) ())))))(defun expand-elastic-space (expansion elastic-list get-elasticity-func set-expansion-func)  (dolist (el elastic-list)    (setf (blocked el) ()))  (let ((continue t))    (loop while continue do      (let* ((elasticity (reduce #'+ elastic-list :key get-elasticity-func))	     (expansion-factor (if (zerop elasticity) 0.0 (/ expansion elasticity))))	(setf continue ())	(dolist (el elastic-list)	  (when (funcall set-expansion-func el expansion-factor)	    (incf expansion (- (initial-value el)(final-value el)))	    (setf continue t)))))))(defun fit-spaces (space-value elastic-list)  (let* ((inital-size (reduce #'+ elastic-list :key #'initial-value))	 (expansion (- space-value inital-size)))    (if (plusp expansion)	(expand-elastic-space expansion elastic-list #'get-elasticity #'expand-elastic)        (expand-elastic-space expansion elastic-list #'get-compressibility #'compress-elastic))))(defun make-composite-elastic (elastic-list)  (make-instance 'elastic		 :value           (reduce #'+ elastic-list :key #'initial-value)		 :min             (reduce #'+ elastic-list :key #'min-value)		 :max             (reduce #'+ elastic-list :key #'max-value)		 :elasticity      (reduce #'+ elastic-list :key #'elasticity)		 :compressibility (reduce #'+ elastic-list :key #'compressibility)))(defun make-parallel-elastic (elastic-list)  (let ((e (make-instance 'elastic			  :value           (reduce #'max elastic-list :key #'initial-value)			  :min             (reduce #'max elastic-list :key #'min-value)			  :max             (reduce #'max elastic-list :key #'max-value)			  :elasticity      (reduce #'max elastic-list :key #'elasticity)			  :compressibility (reduce #'min elastic-list :key #'compressibility))))    (when (> (min-value e) (max-value e))	  (setf (max-value e)(min-value e)))    (when (> (min-value e) (initial-value e))	  (setf (initial-value e)(min-value e)))    (when (> (initial-value e) (max-value e))	  (setf (initial-value e)(max-value e)))    e))(defun global-elasticity (elastic-list)  (let ((n 0)	(sum 0.0))    (dolist (el elastic-list)      (incf n)      (incf sum (elasticity el)))))(defun horizontal-layout (pane-list x y dx dy)  (let ((elastic-list (mapcar #'x-elastic pane-list)))    (fit-spaces dx elastic-list)    (dolist (p pane-list)	    (let ((dx (final-value (x-elastic p))))	      (compute-layout p x y dx dy)	      (incf x dx)))))(defun vertical-layout (pane-list x y dx dy)  (let ((elastic-list (mapcar #'y-elastic pane-list)))    (fit-spaces dy elastic-list)    (dolist (p pane-list)	    (let ((dy (final-value (y-elastic p))))	      (compute-layout p x y dx dy)	      (incf y dy)))))(defun same-place-layout (pane-list x y dx dy)  (let ((elastic-list (mapcar #'y-elastic pane-list)))    (dolist (p pane-list)	      (compute-layout p x y dx dy))))(defclass pane () ((parent-pane         :initform ()  :accessor parent-pane :initarg :parent-pane)  (x-elastic           :initform ()  :accessor x-elastic :initarg :x-elastic)  (y-elastic           :initform ()  :accessor y-elastic :initarg :y-elastic)  (relative-coords     :initform ()  :accessor relative-coords :initarg :relative-coords)  (x              :initform 0.0 :accessor x   :type float)  (y              :initform 0.0 :accessor y   :type float)  (dx             :initform 0.0 :accessor dx  :type float)  (dy             :initform 0.0 :accessor dy  :type float)  (left-border         :initform 0   :accessor left-border   :initarg :left-border)  (top-border          :initform 0   :accessor top-border    :initarg :top-border)  (right-border        :initform 0   :accessor right-border  :initarg :right-border)  (bottom-border       :initform 0   :accessor bottom-border :initarg :bottom-border)  (sub-panes           :initform ()  :accessor sub-panes :initarg :sub-panes)  (layout-pane-func    :initform #'vertical-layout  :accessor layout-pane-func :initarg :layout-pane-func)  (x-compose-pane-func :initform #'make-composite-elastic :accessor x-compose-pane-func :initarg :x-compose-pane-func)  (y-compose-pane-func :initform #'make-composite-elastic :accessor y-compose-pane-func :initarg :y-compose-pane-func)  (need-to-recompute   :initform () :accessor need-to-recompute)  (fixed-elastics      :initform () :accessor fixed-elastics :initarg :fixed-elastics)  (x-value             :initform () :accessor x-value           :initarg :x-value          )  (x-min               :initform () :accessor x-min             :initarg :x-min            )  (x-max               :initform () :accessor x-max             :initarg :x-max            )  (x-elasticity        :initform () :accessor x-elasticity      :initarg :x-elasticity     )  (x-compressibility   :initform () :accessor x-compressibility :initarg :x-compressibility)  (y-value             :initform () :accessor y-value           :initarg :y-value          )  (y-min               :initform () :accessor y-min             :initarg :y-min            )  (y-max               :initform () :accessor y-max             :initarg :y-max            )  (y-elasticity        :initform () :accessor y-elasticity      :initarg :y-elasticity     )  (y-compressibility   :initform () :accessor y-compressibility :initarg :y-compressibility)  (internal-x-elastic  :initform () :accessor internal-x-elastic)  (internal-y-elastic  :initform () :accessor internal-y-elastic)))(defmethod (setf sub-panes) :around (panes (p pane))  (unless (listp panes) (setf panes (list panes)))  (dolist (sub-pane panes)	  (setf (parent-pane sub-pane) p))  (call-next-method panes p)  (setf (need-to-recompute p) t)  (recompute-elastics p))(defun recompute-elastics (p)  (when (need-to-recompute p)	(when (sub-panes p)	      (mapc #'recompute-elastics (sub-panes p))	      (unless (fixed-elastics p)		      (when (x-compose-pane-func p)			    (setf (internal-x-elastic p) (funcall (x-compose-pane-func p) (mapcar #'x-elastic (sub-panes p))))			    (setf (x-elastic p) (duplicate-elastic (internal-x-elastic p))))		      (when (y-compose-pane-func p)			    (setf (internal-y-elastic p) (funcall (y-compose-pane-func p) (mapcar #'y-elastic (sub-panes p))))			    (setf (y-elastic p) (duplicate-elastic (internal-y-elastic p))))))	(let ((x (x-elastic p))	      (y (y-elastic p))	      (dx (+ (left-border p)(right-border p)))	      (dy (+ (top-border p)(bottom-border p))))	  (incf (initial-value x) dx)	  (incf (min-value x) dx)	  (incf (max-value x) dx)	  (incf (initial-value y) dy)	  (incf (min-value y) dy)	  (incf (max-value y) dy)	  (when (x-value p)(setf (initial-value x) (x-value p)))	  (when (x-min p)(setf (min-value x) (x-min p)))	  (when (x-max p)(setf (max-value x) (x-max p)))	  (when (x-elasticity p)(setf (elasticity x) (x-elasticity p)))	  (when (x-compressibility p)(setf (compressibility x) (x-compressibility p)))	  (when (y-value p)(setf (initial-value y) (y-value p)))	  (when (y-min p)(setf (min-value y) (y-min p)))	  (when (y-max p)(setf (max-value y) (y-max p)))	  (when (y-elasticity p)(setf (elasticity y) (y-elasticity p)))	  (when (y-compressibility p)(setf (compressibility y) (y-compressibility p))))	(setf (need-to-recompute p) ())))(defmethod initialize-instance :after ((p pane) &rest init-options &key layout sub-panes &allow-other-keys)  (declare (ignore init-options))  (case layout	(:same-place	 (setf (x-compose-pane-func p) #'make-parallel-elastic)	 (setf (y-compose-pane-func p) #'make-parallel-elastic)	 (setf (layout-pane-func p) #'same-place-layout))	(:vertical	 (setf (x-compose-pane-func p) #'make-parallel-elastic)	 (setf (y-compose-pane-func p) #'make-composite-elastic)	 (setf (layout-pane-func p) #'vertical-layout))	(:horizontal	 (setf (x-compose-pane-func p) #'make-composite-elastic)	 (setf (y-compose-pane-func p) #'make-parallel-elastic)	 (setf (layout-pane-func p) #'horizontal-layout)))  (unless (x-elastic p)	  (if (and sub-panes (x-compose-pane-func p))	      (setf (x-elastic p) (funcall (x-compose-pane-func p) (mapcar #'x-elastic sub-panes)))  	    (setf (x-elastic p) (make-instance 'elastic))))  (unless (y-elastic p)	  (if (and sub-panes (y-compose-pane-func p))	      (setf (y-elastic p) (funcall (y-compose-pane-func p) (mapcar #'y-elastic sub-panes)))  	    (setf (y-elastic p) (make-instance 'elastic))));  (let ((elastic (x-elastic p)));    (when x-value (setf (initial-value elastic) x-value));    (when x-min (setf (min-value elastic) x-min));    (when x-max (setf (max-value elastic) x-max));    (when x-elasticity (setf (elasticity elastic) x-elasticity));    (when x-compressibility (setf (compressibility elastic) x-compressibility)));  (let ((elastic (y-elastic p)));    (when y-value (setf (initial-value elastic) y-value));    (when y-min (setf (min-value elastic) y-min));    (when y-max (setf (max-value elastic) y-max));    (when y-elasticity (setf (elasticity elastic) y-elasticity));    (when y-compressibility (setf (compressibility elastic) y-compressibility)))  (setf (sub-panes p) sub-panes));(defun restore-elastics (p);  (setf (x-elastic p) (original-x-elastic p));  (setf (y-elastic p) (original-y-elastic p)))(defmethod compute-layout ((p pane) x y dx dy)  (setf (x p) x)  (setf (dx p) dx)  (setf (y p) y)  (setf (dy p) dy)  ;  (when (need-to-recompute p);	(if (sub-panes p);	    (setf (x-elastic p) (funcall (x-compose-pane-func p) (mapcar #'x-elastic (sub-panes p)));		  (y-elastic p) (funcall (y-compose-pane-func p) (mapcar #'y-elastic (sub-panes p))));	  (setf (x-elastic p) (make-instance 'elastic);		(y-elastic p) (make-instance 'elastic)));	(setf (need-to-recompute p) ()))  (when (sub-panes p)	(when (relative-coords p) (setf x 0) (setf y 0))	(funcall (layout-pane-func p) (sub-panes p) (+ x (left-border p)) (+ y (top-border p)) (- dx (left-border p)(right-border p)) (- dy (top-border p)(bottom-border p)))))(defun print-list (l)  (dolist (n l)   (format t "initial-value:~F min:~F max:~F elasticity:~F compressibility:~F final-value:~F blocked:~F~%"	   (initial-value n)	   (min-value n)	   (max-value n)	   (elasticity n)	   (compressibility n)	   (final-value n)	   (blocked n))))