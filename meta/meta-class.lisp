(in-package meta)

(defvar *loaded-classes* (make-hash-table))
(defvar *loaded-classes-by-id* (make-hash-table))
(defvar *current-class-info* nil)
(defvar *finalization-class-hooks* nil)

(defconstant +extra-class-options+ '(:guid :user-name :sql-name :description :visible :visible-groups :instanciable :anonymous :short-description :views :functions :rules))

(export 'fc-class)
(clos:defclass fc-class (standard-class)
  ((guid        :accessor guid :initarg :guid)
   (id          :accessor   id)
   (data-class  :accessor data-class :initarg :data-class)
   (user-name   :initform ""  :accessor user-name :initarg :user-name)
   (sql-name  :type string :initarg :sql-name :initform nil :accessor sql-name)
   (description :type string :initarg :description :initform "" :accessor description)
   (version     :accessor version :initform 0 :initarg :version)
   (visible      :initform t   :accessor visible :initarg :visible)
   (visible-groups      :initform t   :accessor visible-groups :initarg :visible-groups)
   (instanciable     :initform t   :accessor instanciable :initarg :instanciable)
   (anonymous        :initform nil :accessor anonymous    :initarg :anonymous)
   (short-description :accessor short-description :initform nil :initarg :short-description)
   (direct-views     :initform () :accessor direct-views :initarg :views)
   (effective-views  :initform () :accessor effective-views)
   (direct-functions :initform () :accessor direct-functions :initarg :functions)
   (effective-functions :initform () :accessor effective-functions :initarg)
   (direct-rules :initform () :accessor direct-rules :initarg :rules)
   (effective-rules :initform () :accessor efective-rules :initarg :effective-rules)))

(defmethod initialize-instance :after ((class fc-class) &rest init-options &key &allow-other-keys)
  (unless (sql-name class)
    (setf (sql-name class) (convert-name-to-sql-name (class-name class))))
  (unless (user-name class) (setf (user-name class) (symbol-name (class-name class))))
  (setf (id class) (guid-to-id (guid class)))
  (let ((old-class (gethash (guid class) *loaded-classes*)))
    (if (and old-class (/= (guid old-class)(guid class)))
      (error "Hash Collision on the guids of the classes ~A and ~A" (user-name old-class)(user-name class))
      (setf (gethash (guid class) *loaded-classes*) class)))
  (let ((old-class (gethash (id class) *loaded-classes-by-id*)))
    (if (and old-class (/= (guid old-class)(guid class)))
      (error "Hash Collision on the ids of the classes ~A and ~A" (user-name old-class)(user-name class))
      (setf (gethash (id class) *loaded-classes-by-id*) class))))

(defmethod reinitialize-instance :after ((class fc-class) &rest init-options &key &allow-other-keys)
  (unless (sql-name class)
    (setf (sql-name class) (convert-name-to-sql-name (class-name class))))
  (unless (user-name class) (setf (user-name class) (symbol-name (class-name class))))
  (setf (id class) (guid-to-id (guid class)))
  (let ((old-class (gethash (guid class) *loaded-classes*)))
    (if (and old-class (/= (guid old-class)(guid class)))
      (error "Hash Collision on the guids of the classes ~A and ~A" (user-name old-class)(user-name class))
      (setf (gethash (guid class) *loaded-classes*) class)))
  (let ((old-class (gethash (id class) *loaded-classes-by-id*)))
    (if (and old-class (/= (guid old-class)(guid class)))
      (error "Hash Collision on the ids of the classes ~A and ~A" (user-name old-class)(user-name class))
      (setf (gethash (id class) *loaded-classes-by-id*) class))))

(defun guid-to-id (guid)
  (mod guid #x80000000))

(defun find-meta-class (id)
  (if (symbolp id)
    (find-class id)
    (gethash id *loaded-classes-by-id*)))

(defmethod clos::canonicalize-class-options :around ((class fc-class) class-options)
  (let ((rest-options ())
	(fc-options ()))
    (dolist (o class-options)
	    (if (eq (first o) :meta-options) (setf fc-options (rest o))
		(push o rest-options)))
    (append (call-next-method class rest-options) fc-options)))

(defun register-class (class class-info data-class)
  (setf (guid class) (guid class-info))
  (setf (data-class class) data-class)
  (setf (class-info class) class-info)
  (setf (gethash (guid class) *loaded-classes*) class))

(defun make-data-name (base-name)
  (intern (concatenate 'string (symbol-name base-name) "-DATA")(symbol-package base-name)))

(defun normalize-real-slot (slot-desc)
  (let ((name (first slot-desc))
	(plist (rest slot-desc)))
    (let ((accessor (getf plist :accessor name))
	  (allocation (getf plist :allocation))
	  (initarg (getf plist :initarg))
	  (type (getf plist :value-type t))
	  (list-of-values (getf plist :list-of-values)))
      (when list-of-values (setf type t))
      (unless (eq allocation :class)(setf allocation nil))
      `(,name :accessor ,accessor
	,@(when initarg (list :initarg initarg))
	,@(when allocation (list :allocation allocation))))))

(defun normalize-virtual-slot (slot-desc)
  (let ((name (first slot-desc))
	(plist (rest slot-desc)))
    (let ((accessor (getf plist :accessor name))
	  (initform (getf plist :initform :no-initform))
	  (type (getf plist :value-type t)))
      (when (eq initform :no-initform)
	(setf initform  (cond
			  ((eq type :date) (get-universal-time))
			  ((eq type :universal-time) (get-universal-time))
			  ((eq type :time-of-day) (get-universal-time))
			  ((eq type 'pathname) #P"")
			  ((eq type :decimal) 0.0)
			  ((safe-subtypep type 'string) "")
			  ((safe-subtypep type 'float) 0.0)
			  ((safe-subtypep type 'number) 0)
			  (t nil)))
	(setf (getf plist :initform) initform))
      (setf (getf plist :value-type) (list 'quote type))
      `(,name :vaccessor ',accessor ,@plist))))

(export 'defclass)
(defmacro defclass (name supers &optional slot-specifiers &rest options)
  (let ((class-info-options ()))
    (setf options (loop for option in options
			if (member :guid option)
			do (setf class-info-options option)
			else collect option))
    (if class-info-options
      (let ((data-name (make-data-name name))
	    (data-supers (mapcar 'make-data-name supers))
	    (normalized-slot-specifiers (loop for slot-spec in slot-specifiers
					      unless (getf (rest slot-spec) :in-proxy)
					      collect (normalize-real-slot slot-spec)))
	    (proxy-slot-specifiers ()))
	(when (and (not (member 'root-object supers)) (not (eq name 'root-object)))
	  (setf supers (append supers (list 'root-object))
		data-supers (append data-supers (list 'root-object-data))))
	`(let ((data-class (clos:defclass ,data-name ,data-supers ,normalized-slot-specifiers))
	       (class (clos:defclass ,name ,supers ,(mapcar 'normalize-virtual-slot slot-specifiers)
				     ,@(list* `(:meta-options ,@class-info-options)
					      '(:metaclass fc-class) (remove :metaclass options :key #'first)))))
	  (setf (data-class class) data-class)
;	  ,@(mapcan #'(lambda (s) (make-virtual-slot name s)) slot-specifiers)
	  class))
      `(clos:defclass ,name ,supers ,slot-specifiers ,@options))))

(defun convert-name-to-sql-name (name)
  (nstring-downcase (substitute #\_ #\- (if (symbolp name) (symbol-name name) name))))

(export 'fc-class-p)
(defun fc-class-p (class)
  (let ((result nil))
    (ignore-errors
      (setf result (subtypep class 'root-object)))
    result))

(defmethod finalize-inheritance :after ((class fc-class))
  (create-short-description class)
  (compute-effective-functions class)
  (compile-predicates class)
  (create-direct-accessors class)
  (dolist (fn *finalization-class-hooks*)
    (funcall fn class)))

(defmethod effective-functions :before ((class fc-class))
  (unless (clos:class-finalized-p class) (clos:finalize-inheritance class)))

(defun create-direct-accessors (class)
  (let ((accessors ()))
    (dolist (slot (class-effective-slots class))
	    (unless (in-proxy slot)
	      (push (create-read-accessor class slot) accessors)
	      (push (create-setf-accessor class slot) accessors)))
    (funcall (compile nil (list* 'lambda () accessors)))))

(defun compute-effective-functions (class)
  (setf (effective-functions class)
	(nconc (copy-list (direct-functions class))
	       (mapcan #'(lambda(c)
			   (when (fc-class-p c)(compute-effective-functions c)))
		       (clos:class-direct-superclasses class)))))

(defun create-read-accessor (class slot)
  (let ((accessor (accessor slot)))
    `(defmethod ,accessor ((obj ,(class-name class)))
      (let* ((data (data-object obj))
	     (value (if data (,accessor data)(progn (load-object-data obj)(,accessor (data-object obj))))))
	,@(when (eq (value-type slot) :decimal) `((setf value (* value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
	value))))

(defun create-setf-accessor (class slot)
  (let ((accessor (accessor slot)))
    `(defmethod (setf ,accessor) (value (obj ,(class-name class)))
      ,@(when (value-constraint-fn slot) `((unless (funcall (value-constraint-fn ,slot) obj value)(return-from ,accessor (,accessor obj)))))
      (let ((data (data-object obj)))
	,@(when (eq (value-type slot) :decimal) `((setf value (fround value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
	(if data (setf (,accessor data) value)(progn (load-object-data obj)(setf (,accessor (data-object obj)) value)))
	,@(when (eq (value-type slot) :decimal) `((setf value (* value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
	(mark-object-as-modified obj)
	(fire-slot-value-changed obj ,slot value)
	value))))

(defun compile-predicates (class)
  (dolist (slot (class-slots class))
    (compile-predicate slot class)
    (compile-value-constraint slot class))
  (dolist (fn (effective-functions class))
    (compile-predicate fn class)))

(defun initialize-unbound-slots (object)
  (let ((data-object (load-object-data object))
	(*parent-of-root-object-initialized* object))
    (dolist (slot (class-slots (class-of object)))
	(if (in-proxy slot)
	    (when (and (not (slot-boundp object (slot-definition-name slot)))
		       (slot-definition-initfunction slot))
	      (setf (slot-value object (slot-definition-name slot))
		    (funcall (slot-definition-initfunction slot))))
	    (when (and (not (slot-boundp data-object (slot-definition-name slot)))
		       (slot-definition-initfunction slot))
	      (setf (slot-value data-object (slot-definition-name slot))
		    (funcall (slot-definition-initfunction slot))))))))

(defun initialize-disable-predicates (object)
 (let ((class (class-of object)))
   (when (data-object object)
     (dolist (slot (class-slots class))
       (when (disable-predicate-fn slot)
	 (funcall (disable-predicate-fn slot) object)))
     (dolist (fn (effective-functions class))
       (when (disable-predicate-fn fn)
	 (funcall (disable-predicate-fn fn) object))))))

(defun create-short-description (class)
  (when (short-description class)
    (let ((*package* (symbol-package (class-name class))))
      (funcall (compile nil `(lambda ()
			      (defmethod meta::short-description ((,(intern "OBJECT") ,(class-name class)))
				,(if (symbolp (short-description class))
				     `(,(short-description class) ,(intern "OBJECT"))
				     (short-description class)))))))))

(defun add-finalization-class-hook (fn)
  (pushnew fn *finalization-class-hooks*))