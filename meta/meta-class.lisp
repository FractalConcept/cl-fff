(in-package meta)

(defvar *loaded-classes* (make-hash-table))
(defvar *loaded-classes-by-id* (make-hash-table))
(defvar *current-class-info* nil)
(defvar *finalization-class-hooks* nil)

(defconstant +extra-class-options+ '(:guid :user-name :sql-name :description :visible :visible-groups :instanciable :anonymous :short-description :views :functions :rules))

(export 'fc-class)
(cl:defclass fc-class (standard-class)
  ((guid        :accessor guid :initarg :guid)
   (id          :accessor   id)
   (data-class  :accessor data-class :initarg :data-class)
   (user-name   :initform ""  :accessor user-name :initarg :user-name)
   (sql-name  :type string :initarg :sql-name :initform nil :accessor sql-name)
   (description :type string :initarg :description :initform "" :accessor description)
   (version     :accessor version :initform 0 :initarg :version)
   (visible      :initform t   :accessor visible :initarg :visible)
   (visible-groups      :initform t   :accessor visible-groups :initarg :visible-groups)
   (instanciable     :initform t   :accessor instanciable :initarg :instanciable)
   (anonymous        :initform nil :accessor anonymous    :initarg :anonymous)
   (short-description :accessor short-description :initform nil :initarg :short-description)
   (direct-views     :initform () :accessor direct-views :initarg :views)
   (effective-views  :initform () :accessor effective-views)
   (direct-functions :initform () :accessor direct-functions :initarg :functions)
   (effective-functions :initform () :accessor effective-functions :initarg :effective-functions)
   (direct-rules :initform () :accessor direct-rules :initarg :rules)
   (effective-rules :initform () :accessor efective-rules :initarg :effective-rules)))

(defmethod initialize-instance :after ((class fc-class) &rest init-options &key &allow-other-keys)
  (unless (sql-name class)
    (setf (sql-name class) (convert-name-to-sql-name (class-name class))))
  (unless (user-name class) (setf (user-name class) (symbol-name (class-name class))))
  (setf (id class) (guid-to-id (guid class)))
  (let ((old-class (gethash (guid class) *loaded-classes*)))
    (if (and old-class (/= (guid old-class) (guid class)))
        (error "Hash Collision on the guids of the classes ~A and ~A" (user-name old-class) (user-name class))
        (setf (gethash (guid class) *loaded-classes*) class)))
  (let ((old-class (gethash (id class) *loaded-classes-by-id*)))
    (if (and old-class (/= (guid old-class) (guid class)))
        (error "Hash Collision on the ids of the classes ~A and ~A" (user-name old-class) (user-name class))
        (setf (gethash (id class) *loaded-classes-by-id*) class))))

(defmethod reinitialize-instance :after ((class fc-class) &rest init-options &key &allow-other-keys)
  (unless (sql-name class)
    (setf (sql-name class) (convert-name-to-sql-name (class-name class))))
  (unless (user-name class) (setf (user-name class) (symbol-name (class-name class))))
  (setf (id class) (guid-to-id (guid class)))
  (let ((old-class (gethash (guid class) *loaded-classes*)))
    (if (and old-class (/= (guid old-class) (guid class)))
        (error "Hash Collision on the guids of the classes ~A and ~A" (user-name old-class) (user-name class))
        (setf (gethash (guid class) *loaded-classes*) class)))
  (let ((old-class (gethash (id class) *loaded-classes-by-id*)))
    (if (and old-class (/= (guid old-class) (guid class)))
        (error "Hash Collision on the ids of the classes ~A and ~A" (user-name old-class) (user-name class))
        (setf (gethash (id class) *loaded-classes-by-id*) class))))

(defun guid-to-id (guid)
  (mod guid #x80000000))

(defun find-meta-class (id)
  (if (symbolp id)
      (find-class id)
      (gethash id *loaded-classes-by-id*)))

#+lispworks
(defmethod clos::canonicalize-class-options :around ((class fc-class) class-options) ;; FIXME
  (let ((rest-options ())
        (fc-options ()))
    (dolist (o class-options)
      (if (eq (first o) :meta-options)
          (setf fc-options (rest o))
          (push o rest-options)))
    (append (call-next-method class rest-options) fc-options)))

#-lispworks
(warn "canonicalize-class-options method not found")

(defun register-class (class class-info data-class)
  (setf (guid class) (guid class-info))
  (setf (data-class class) data-class)
  (setf (class-info class) class-info) ;; FIXME
  (setf (gethash (guid class) *loaded-classes*) class))

(defun make-data-name (base-name)
  (intern (concatenate 'string (symbol-name base-name) "-DATA") (symbol-package base-name)))

(defun normalize-real-slot (slot-desc)
  (let ((name (first slot-desc))
        (plist (rest slot-desc)))
    (let ((accessor (getf plist :accessor name))
          (allocation (getf plist :allocation))
          (initarg (getf plist :initarg))
          ;; (type (getf plist :value-type t))
          ;; (list-of-values (getf plist :list-of-values))
          )
      #+nil(when list-of-values
        (setf type t))
      (unless (eq allocation :class)
        (setf allocation nil))
      `(,name :accessor ,accessor
              ,@(when initarg (list :initarg initarg))
              ,@(when allocation (list :allocation allocation))))))

(defun safe-subtypep (type1 type2)
  (let ((result nil))
    (ignore-errors
      (setf result (subtypep type1 type2)))
    result))

(defun normalize-virtual-slot (slot-desc)
  (let ((name (first slot-desc))
        (plist (rest slot-desc)))
    (let ((accessor (getf plist :accessor name))
          (initform (getf plist :initform :no-initform))
          (type (getf plist :value-type t)))
      (when (eq initform :no-initform)
        (setf initform  (cond
                          ((eq type 'date) '(get-universal-time))
                          ((eq type 'universal-time) '(get-universal-time))
                          ((eq type 'time-of-day) '(get-universal-time))
                          ((eq type 'pathname) #P"")
                          ((eq type 'decimal) 0.0)
                          ((safe-subtypep type 'string) "")
                          ((safe-subtypep type 'float) 0.0)
                          ((safe-subtypep type 'number) 0)
                          (t nil)))
        (setf (getf plist :initform) initform))
      (setf (getf plist :value-type) (list 'quote type))
      `(,name :vaccessor ',accessor ,@plist))))

(export 'defclass)
(defmacro defclass (name supers &optional slot-specifiers &rest options)
  (let ((class-info-options ()))
    (setf options (loop for option in options
                     if (member :guid option)
                     do (setf class-info-options option)
                     else collect option))
    (if class-info-options
        (let ((data-name (make-data-name name))
              (data-supers (mapcar 'make-data-name supers))
              (normalized-slot-specifiers (loop for slot-spec in slot-specifiers
                                             unless (getf (rest slot-spec) :in-proxy)
                                             collect (normalize-real-slot slot-spec)))
              #+nil(proxy-slot-specifiers ()))
          (when (and (not (member 'root-object supers)) (not (eq name 'root-object)))
            (setf supers (append supers (list 'root-object))
                  data-supers (append data-supers (list 'root-object-data))))
          `(let ((data-class (cl:defclass ,data-name ,data-supers ,normalized-slot-specifiers))
                 (class (cl:defclass ,name ,supers ,(mapcar 'normalize-virtual-slot slot-specifiers)
                          ,@(list* `(:meta-options ,@class-info-options)
                                   '(:metaclass fc-class) (remove :metaclass options :key #'first)))))
             (setf (data-class class) data-class)
             ;; ,@(mapcan #'(lambda (s) (make-virtual-slot name s)) slot-specifiers)
             class))
        `(cl:defclass ,name ,supers ,slot-specifiers ,@options))))

(defun convert-name-to-sql-name (name)
  (nstring-downcase (substitute #\_ #\- (if (symbolp name) (symbol-name name) name))))

(export 'fc-class-p)
(defun fc-class-p (class)
  (let ((result nil))
    (ignore-errors
      (setf result (subtypep class 'root-object)))
    result))

(defmethod finalize-inheritance :after ((class fc-class))
  (create-short-description class)
  (compute-effective-functions class)
  (compile-predicates class)
  (create-direct-accessors class)
  (dolist (fn *finalization-class-hooks*)
    (funcall fn class)))

(defmethod effective-functions :before ((class fc-class))
  (unless (c2mop:class-finalized-p class) (c2mop:finalize-inheritance class)))

(defun create-direct-accessors (class)
  (let ((accessors ()))
    #+lispworks
    (dolist (slot (clos:class-effective-slots class)) ;;LW only! ;; FIXME
      (unless (in-proxy slot)
        (push (create-read-accessor class slot) accessors)
        (push (create-setf-accessor class slot) accessors)))
    #-lispworks
    (error "implement class-effective-slots")
    (funcall (compile nil (list* 'lambda () accessors)))))

(defun compute-effective-functions (class)
  (setf (effective-functions class)
        (nconc (copy-list (direct-functions class))
               (mapcan #'(lambda(c)
                           (when (fc-class-p c) (compute-effective-functions c)))
                       (c2mop:class-direct-superclasses class)))))

(defun create-read-accessor (class slot)
  (let ((accessor (accessor slot)))
    `(defmethod ,accessor ((obj ,(class-name class)))
       (let* ((data (data-object obj))
              (value (if data (,accessor data) (progn (load-object-data obj) (,accessor (data-object obj))))))
         ,@(when (eq (value-type slot) 'meta::decimal) `((setf value (* value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
         value))))

(defun create-setf-accessor (class slot)
  (let ((accessor (accessor slot)))
    `(defmethod (setf ,accessor) (value (obj ,(class-name class)))
       ,@(when (value-constraint-fn slot) `((unless (funcall (value-constraint-fn ,slot) obj value) (return-from ,accessor (,accessor obj)))))
       (let ((data (data-object obj)))
         ,@(when (eq (value-type slot) 'meta::decimal) `((setf value (fround value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
         (if data (setf (,accessor data) value) (progn (load-object-data obj) (setf (,accessor (data-object obj)) value)))
         ,@(when (eq (value-type slot) 'meta::decimal) `((setf value (* value ,(/ 1.0 (expt 10 (nb-decimals slot)))))))
         (mark-object-as-modified obj)
         (fire-slot-value-changed obj ,slot value)
         value))))

(defun compile-predicates (class)
  (dolist (slot (c2mop:class-slots class))
    (compile-predicate slot class)
    (compile-value-constraint slot class))
  (dolist (fn (effective-functions class))
    (compile-predicate fn class)))

(defun initialize-unbound-slots (object)
  (let ((data-object (load-object-data object))
        (*parent-of-root-object-initialized* object))
    (dolist (slot (c2mop:class-slots (class-of object)))
      (if (in-proxy slot)
          (when (and (not (slot-boundp object (c2mop:slot-definition-name slot)))
                     (c2mop:slot-definition-initfunction slot))
            (setf (slot-value object (c2mop:slot-definition-name slot))
                  (funcall (c2mop:slot-definition-initfunction slot))))
          (when (and (not (slot-boundp data-object (c2mop:slot-definition-name slot)))
                     (c2mop:slot-definition-initfunction slot))
            (setf (slot-value data-object (c2mop:slot-definition-name slot))
                  (funcall (c2mop:slot-definition-initfunction slot))))))))

(defun initialize-disable-predicates (object)
  (let ((class (class-of object)))
    (when (data-object object)
      (dolist (slot (c2mop:class-slots class))
        (when (disable-predicate-fn slot)
          (funcall (disable-predicate-fn slot) object)))
      (dolist (fn (effective-functions class))
        (when (disable-predicate-fn fn)
          (funcall (disable-predicate-fn fn) object))))))

(defun create-short-description (class)
  (when (short-description class)
    (let ((*package* (symbol-package (class-name class))))
      (funcall (compile nil `(lambda ()
                               (defmethod meta::short-description ((,(intern "OBJECT") ,(class-name class)))
                                 ,(if (symbolp (short-description class))
                                      `(,(short-description class) ,(intern "OBJECT"))
                                      (short-description class)))))))))

(defun add-finalization-class-hook (fn)
  (pushnew fn *finalization-class-hooks*))
